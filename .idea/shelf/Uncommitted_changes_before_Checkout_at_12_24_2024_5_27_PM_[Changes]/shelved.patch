Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import copy\r\n\r\nclass Board:\r\n    def __init__(self, side_length):\r\n        self.side_length = side_length\r\n        self.state = self.initialize_board()\r\n        self.sticks = set()\r\n        self.triangles = {}\r\n\r\n    def initialize_board(self):\r\n        return (\r\n                [[None] * (self.side_length + i) for i in range(self.side_length)] +  # Upper triangle\r\n                [[None] * (2 * self.side_length - i - 1) for i in range(1, self.side_length)]  # Lower triangle\r\n        )\r\n\r\n\r\nclass GameRendered:\r\n\r\n    def display_board(self, board: Board):\r\n        n = board.side_length\r\n        max_width = 2 * board.side_length - 1\r\n        column_numbers = '     '.join(f\"{i}\" for i in range(1, max_width + 1))\r\n\r\n        # Display column numbers\r\n        print(f\"   {'   ' * (n - 1)}{column_numbers}\")\r\n\r\n        for i in range(len(board.state)):\r\n\r\n            offset = abs(n - 1 - i)  # Indent for alignment\r\n            row_label = chr(65 + i)\r\n\r\n            # Peg line\r\n            peg_line = []\r\n            for j in range(len(board.state[i])):\r\n                peg_line.append(\"●\")\r\n                peg_line.append(\"-----\" if self.is_part_of_horizontal_stick(board, i, j) else \"     \")\r\n\r\n            # First triangle line (diagonal sticks)\r\n            first_triangle_line = []\r\n            for j in range(len(board.state[i])):\r\n                down_left = self.is_part_of_diagonal_stick(board, i, j, \"DL\")\r\n                down_right = self.is_part_of_diagonal_stick(board, i, j, \"DD\")\r\n\r\n                # Add left diagonal\r\n                first_triangle_line.append(\"/\" if down_left else \" \")\r\n\r\n                # Add space between left and right diagonals\r\n                first_triangle_line.append(\" \" * 1)\r\n\r\n                # Add right diagonal\r\n                first_triangle_line.append(\"\\\\\" if down_right else \" \")\r\n                #first_triangle_line.append(\"   \")\r\n\r\n                # Get the triangle owner upper\r\n                triangle_owner = self.get_triangle_owner(board, i, j, True)\r\n                first_triangle_line.append(f\" {triangle_owner} \")\r\n\r\n            # Second triangle line\r\n            second_triangle_line = []\r\n            for j in range(len(board.state[i])):\r\n                down_left = self.is_part_of_diagonal_stick(board, i, j, \"DL\")\r\n                second_triangle_line.append(\"/\" if down_left else \" \")\r\n\r\n                # Add the triangle owner\r\n                triangle_owner = self.get_triangle_owner(board, i, j, False)\r\n                second_triangle_line.append(f\"{triangle_owner}\")\r\n\r\n                down_right = self.is_part_of_diagonal_stick(board,i, j, \"DD\")\r\n                second_triangle_line.append(\"\\\\\" if down_right else \" \")\r\n\r\n            # Print peg line\r\n            print(f\"{row_label} {'   ' * offset}{''.join(peg_line)}\")\r\n\r\n            if i < len(board.state) - 1:  # Avoid printing after the last peg line\r\n                print(f\" {'   ' * offset}{''.join(first_triangle_line)}\")\r\n                print(f\"{'   ' * offset}{' '.join(second_triangle_line)}\")\r\n\r\n        print(f\"   {'   ' * (n - 1)}{column_numbers}\")\r\n\r\n    @staticmethod\r\n    def is_part_of_horizontal_stick(board: Board, row, col):\r\n        if ((row, col), (row, col + 1)) in board.sticks:\r\n            return True\r\n        return False\r\n\r\n    @staticmethod\r\n    def is_part_of_diagonal_stick(board: Board, row, col, direction):\r\n        if direction == \"DL\" and row < board.side_length - 1:  #\r\n            return ((row, col), (row + 1, col)) in board.sticks or ((row + 1, col), (row, col)) in board.sticks\r\n        if direction == \"DL\" and row >= board.side_length - 1:\r\n            return ((row, col), (row + 1, col-1)) in board.sticks or ((row + 1, col-1), (row, col)) in board.sticks\r\n        if direction == \"DD\" and row < board.side_length - 1:\r\n            return ((row, col), (row + 1, col + 1)) in board.sticks or ((row + 1, col + 1), (row, col)) in board.sticks\r\n        if direction == \"DD\" and row >= board.side_length - 1:\r\n            return ((row, col), (row + 1, col)) in board.sticks or ((row + 1, col), (row, col)) in board.sticks\r\n        return False\r\n\r\n    @staticmethod\r\n    def get_triangle_owner(board: Board, row, col, downward):\r\n        triangle_owner = \" \"\r\n\r\n        # Determine potential triangles based on `firstRow` flag\r\n        if downward:  # Use downward-facing triangle formula\r\n            if row < board.side_length - 1:  # Upper triangle board\r\n                potential_triangles = [\r\n                    [(row, col), (row, col + 1), (row + 1, col+1)]  # Downward-facing triangle\r\n                ]\r\n            else:  # Lower triangle board\r\n                potential_triangles = [\r\n                    [(row, col), (row, col + 1), (row + 1, col)]  # Downward-facing triangle\r\n                ]\r\n        else:  # Use upward-facing triangle formula\r\n            if row < board.side_length - 1:  # Upper triangle board\r\n                potential_triangles = [\r\n                    [(row, col), (row + 1, col), (row + 1, col + 1)]  # Upward-facing triangle\r\n                ]\r\n            else:  # Lower triangle board\r\n                potential_triangles = [\r\n                    [(row, col), (row + 1, col - 1), (row + 1, col)]  # Upward-facing triangle\r\n                ]\r\n\r\n        # Check ownership for potential triangles\r\n        for corners in potential_triangles:\r\n            triangle_key = tuple(sorted(corners))\r\n            if triangle_key in board.triangles:\r\n                triangle_owner = board.triangles[triangle_key]\r\n                break  # Return the first matching triangle's owner\r\n\r\n        return triangle_owner\r\n\r\n\r\nclass TriggleGame:\r\n    def __init__(self, side_length,first_player):\r\n        self.board = Board(side_length)\r\n        self.game_rendered = GameRendered()\r\n        self.current_player = first_player\r\n        self.max_sticks = None\r\n        self.max_triangles = self.calculate_max_triangles()\r\n        self.peg_number = None\r\n\r\n    def display_board(self):\r\n        self.game_rendered.display_board(self.board)\r\n\r\n    def is_valid_move(self, row, col, direction):\r\n\r\n        occupied = True\r\n\r\n        r, c = row, col\r\n\r\n        for step in range(3):\r\n            # Set deltas based on the current row\r\n            if r < self.board.side_length - 1:  # Upper triangle\r\n                deltas = {\r\n                    'D': (0, 1),\r\n                    'DL': (1, 0),\r\n                    'DD': (1, 1)\r\n                }\r\n            else:  # Lower triangle\r\n                deltas = {\r\n                    'D': (0, 1),\r\n                    'DL': (1, -1),\r\n                    'DD': (1, 0)\r\n                }\r\n\r\n            if direction not in deltas:\r\n                return False, \"Invalid direction. Use 'D', 'DL', or 'DD'.\"\r\n\r\n            dr, dc = deltas[direction]\r\n            next_r, next_c = r + dr, c + dc\r\n\r\n            # Check if the new position is within bounds\r\n            if not (0 <= next_r < len(self.board.state) and 0 <= next_c < len(self.board.state[next_r])):\r\n                return False, f\"Peg at step {step + 1} is out of bounds.\"\r\n\r\n            # Check if there's a stick already in this step\r\n            if not (((r, c), (next_r, next_c)) in self.board.sticks):\r\n                occupied = False\r\n\r\n            r, c = next_r, next_c\r\n\r\n        if occupied:\r\n            return False, \"This move is invalid: All steps in the path are occupied.\"\r\n\r\n        return True, None\r\n\r\n    def make_move(self, row, col, direction):\r\n\r\n        is_valid, error_message = self.is_valid_move(row, col, direction)\r\n        if not is_valid:\r\n            raise ValueError(error_message)\r\n\r\n        r, c = row, col\r\n\r\n        for _ in range(3):\r\n\r\n            # Update deltas based on the current value of r\r\n\r\n            #TOP TRIANGLE\r\n            if r < self.board.side_length - 1:\r\n                deltas = {\r\n                    'D': (0, 1),\r\n                    'DL': (1, 0),\r\n                    'DD': (1, 1)\r\n                }\r\n            else:\r\n                #BOTTOM TRIANGLE\r\n                deltas = {\r\n                    'D': (0, 1),\r\n                    'DL': (1, -1),\r\n                    'DD': (1, 0)\r\n                }\r\n\r\n            dr, dc = deltas[direction]\r\n\r\n            if not (0 <= r < len(self.board.state) and 0 <= c < len(self.board.state[r])):\r\n                raise ValueError(\"Move out of bounds.\")\r\n\r\n            next_r, next_c = r + dr, c + dc\r\n            self.board.sticks.add(((r, c), (next_r, next_c)))\r\n\r\n            r, c = next_r, next_c\r\n\r\n        self.check_and_capture_triangles()\r\n        self.switch_player()\r\n\r\n    def check_and_capture_triangles(self):\r\n        def is_triangle_completed(corners):\r\n            return all(\r\n                ((corners[i], corners[(i + 1) % len(corners)]) in self.board.sticks or\r\n                 (corners[(i + 1) % len(corners)], corners[i]) in self.board.sticks)\r\n                for i in range(len(corners))\r\n            )\r\n\r\n        # Traverse the board\r\n        for row in range(len(self.board.state)):\r\n            for col in range(len(self.board.state[row])):\r\n                potential_triangles = []\r\n\r\n                # Add potential triangles based on the peg's location\r\n                if row < self.board.side_length - 1:  # Upper triangle\r\n                    potential_triangles.extend([\r\n                        # Triangle facing down\r\n                        [(row, col), (row, col + 1), (row + 1, col+1)],\r\n                        # Triangle facing up\r\n                        [(row, col), (row + 1, col), (row + 1, col + 1)]\r\n                    ])\r\n                else:  # Lower triangle\r\n                    potential_triangles.extend([\r\n                        # Triangle facing down\r\n                        [(row, col), (row, col + 1), (row + 1, col)],\r\n                        # Triangle facing up\r\n                        [(row, col), (row + 1, col - 1), (row + 1, col)]\r\n                    ])\r\n\r\n                # Check each potential triangle\r\n                for corners in potential_triangles:\r\n                    if is_triangle_completed(corners):\r\n                        # Sort the corners to have a consistent representation\r\n                        triangle_key = tuple(sorted(corners))\r\n                        if triangle_key not in self.board.triangles:\r\n                            self.board.triangles[triangle_key] = self.current_player\r\n\r\n    def switch_player(self):\r\n        self.current_player = 'X' if self.current_player == 'O' else 'O'\r\n\r\n    def is_game_over(self):\r\n\r\n        x_count = sum(1 for owner in self.board.triangles.values() if owner == 'X')\r\n        o_count = sum(1 for owner in self.board.triangles.values() if owner == 'O')\r\n        print(\"Scoreboard\")\r\n        print(f\"X: {'█' * x_count} ({x_count})\")\r\n        print(f\"O: {'█' * o_count} ({o_count})\")\r\n\r\n        if x_count + o_count == self.max_triangles:\r\n            print(\"Game over: All triangles are captured.\")\r\n            return True\r\n\r\n        if x_count > self.max_triangles // 2:\r\n            print(\"Game over: Player X has won by majority!\")\r\n            return True\r\n\r\n        if o_count > self.max_triangles // 2:\r\n            print(\"Game over: Player O has won by majority!\")\r\n            return True\r\n\r\n        if len(self.board.sticks) == self.max_sticks:\r\n            print(\"Game over: All sticks are placed.\")\r\n            return True\r\n\r\n        return False\r\n\r\n    def calculate_max_triangles(self):\r\n        max_triangles = 0\r\n        for step in range(self.board.side_length - 1):\r\n            max_triangles += 2 * len(self.board.state[step]) - 1\r\n        max_triangles = max_triangles * 2\r\n        return max_triangles\r\n\r\n    def calculate_max_sticks(self):\r\n        corner_connections = 6 * 3\r\n        side_connections = (self.board.side_length - 2) * 4 * 6\r\n        center_connections = (self.peg_number - 6 - (self.board.side_length - 2) * 6) * 6\r\n        total_connections = corner_connections + side_connections + center_connections\r\n        number_of_sticks = total_connections / 2\r\n        return number_of_sticks\r\n\r\n    def get_all_possible_moves(self):\r\n\r\n        possible_moves = []\r\n\r\n        for row in range(len(self.board.state)):\r\n            for col in range(len(self.board.state[row])):\r\n                for direction in ['D', 'DL', 'DD']:\r\n                    is_valid, _ = self.is_valid_move(row, col, direction)\r\n                    if is_valid:\r\n                        possible_moves.append((row, col, direction))\r\n        return possible_moves\r\n\r\n    def get_all_possible_states(self):\r\n\r\n        possible_moves = self.get_all_possible_moves()\r\n        possible_states = []\r\n\r\n        for move in possible_moves:\r\n            new_state = copy.deepcopy(self)\r\n\r\n            # Apply the move to the new state\r\n            row, col, direction = move\r\n            new_state.make_move(row, col, direction)\r\n\r\n            # Add the new state to the list\r\n            possible_states.append(new_state)\r\n\r\n        return possible_states\r\n\r\ndef setup_game():\r\n    n = int(input(\"Enter the side length of the hexagonal board (4-8): \"))\r\n    if n < 4 or n > 8:\r\n        raise ValueError(\"Side length must be between 4 and 8.\")\r\n\r\n    first_player = input(\"Who will play first? (X/O): \").strip().upper()\r\n    if first_player not in ['X', 'O']:\r\n        raise ValueError(\"Invalid choice. Choose 'X' or 'O'.\")\r\n\r\n    game = TriggleGame(n, first_player)\r\n\r\n    game.peg_number = sum(len(row) for row in game.board.state)\r\n    game.max_sticks = game.calculate_max_sticks()\r\n\r\n    return game\r\n\r\ndef main():\r\n    game = setup_game()\r\n\r\n    while not game.is_game_over():\r\n        print(f\"\\n{game.current_player}'s turn.\")\r\n        game.display_board()\r\n\r\n        try:\r\n            move = input(\"Enter your move (format: row column direction): \").strip()\r\n            row, col, direction = move.rsplit(' ', 2)\r\n            row, col = ord(row.upper()) - 65, int(col) - 1\r\n            direction = direction.upper()\r\n            game.make_move(row, col, direction)\r\n\r\n        except ValueError as e:\r\n            print(f\"Error: {e}\")\r\n        except Exception as e:\r\n            print(f\"Unexpected error: {e}\")\r\n\r\n    game.display_board()\r\n    print(\"\\nGame Over!\")\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision fe3ef5e37143e9b96350c68fb9144c256179c829)
+++ b/main.py	(date 1734718730842)
@@ -13,6 +13,48 @@
                 [[None] * (2 * self.side_length - i - 1) for i in range(1, self.side_length)]  # Lower triangle
         )
 
+    def is_valid_move(self, row, col, direction):
+
+        occupied = True
+
+        r, c = row, col
+
+        for step in range(3):
+            # Set deltas based on the current row
+            if r < self.side_length - 1:  # Upper triangle
+                deltas = {
+                    'D': (0, 1),
+                    'DL': (1, 0),
+                    'DD': (1, 1)
+                }
+            else:  # Lower triangle
+                deltas = {
+                    'D': (0, 1),
+                    'DL': (1, -1),
+                    'DD': (1, 0)
+                }
+
+            if direction not in deltas:
+                return False, "Invalid direction. Use 'D', 'DL', or 'DD'."
+
+            dr, dc = deltas[direction]
+            next_r, next_c = r + dr, c + dc
+
+            # Check if the new position is within bounds
+            if not (0 <= next_r < len(self.state) and 0 <= next_c < len(self.state[next_r])):
+                return False, f"Peg at step {step + 1} is out of bounds."
+
+            # Check if there's a stick already in this step
+            if not (((r, c), (next_r, next_c)) in self.sticks):
+                occupied = False
+
+            r, c = next_r, next_c
+
+        if occupied:
+            return False, "This move is invalid: All steps in the path are occupied."
+
+        return True, None
+
 
 class GameRendered:
 
@@ -141,51 +183,10 @@
     def display_board(self):
         self.game_rendered.display_board(self.board)
 
-    def is_valid_move(self, row, col, direction):
-
-        occupied = True
-
-        r, c = row, col
-
-        for step in range(3):
-            # Set deltas based on the current row
-            if r < self.board.side_length - 1:  # Upper triangle
-                deltas = {
-                    'D': (0, 1),
-                    'DL': (1, 0),
-                    'DD': (1, 1)
-                }
-            else:  # Lower triangle
-                deltas = {
-                    'D': (0, 1),
-                    'DL': (1, -1),
-                    'DD': (1, 0)
-                }
-
-            if direction not in deltas:
-                return False, "Invalid direction. Use 'D', 'DL', or 'DD'."
-
-            dr, dc = deltas[direction]
-            next_r, next_c = r + dr, c + dc
-
-            # Check if the new position is within bounds
-            if not (0 <= next_r < len(self.board.state) and 0 <= next_c < len(self.board.state[next_r])):
-                return False, f"Peg at step {step + 1} is out of bounds."
-
-            # Check if there's a stick already in this step
-            if not (((r, c), (next_r, next_c)) in self.board.sticks):
-                occupied = False
-
-            r, c = next_r, next_c
-
-        if occupied:
-            return False, "This move is invalid: All steps in the path are occupied."
-
-        return True, None
 
     def make_move(self, row, col, direction):
 
-        is_valid, error_message = self.is_valid_move(row, col, direction)
+        is_valid, error_message = self.board.is_valid_move(row, col, direction)
         if not is_valid:
             raise ValueError(error_message)
 
@@ -304,50 +305,67 @@
         number_of_sticks = total_connections / 2
         return number_of_sticks
 
-    def get_all_possible_moves(self):
+def setup_game():
+    n = int(input("Enter the side length of the hexagonal board (4-8): "))
+    if n < 4 or n > 8:
+        raise ValueError("Side length must be between 4 and 8.")
+
+    first_player = input("Who will play first? (X/O): ").strip().upper()
+    if first_player not in ['X', 'O']:
+        raise ValueError("Invalid choice. Choose 'X' or 'O'.")
+
+    game = TriggleGame(n, first_player)
+
+    game.peg_number = sum(len(row) for row in game.board.state)
+    game.max_sticks = game.calculate_max_sticks()
+
+    return game
+
+def get_all_possible_moves(board: Board):
 
-        possible_moves = []
+    possible_moves = []
 
-        for row in range(len(self.board.state)):
-            for col in range(len(self.board.state[row])):
-                for direction in ['D', 'DL', 'DD']:
-                    is_valid, _ = self.is_valid_move(row, col, direction)
-                    if is_valid:
-                        possible_moves.append((row, col, direction))
-        return possible_moves
+    for row in range(len(board.state)):
+        for col in range(len(board.state[row])):
+            for direction in ['D', 'DL', 'DD']:
+                is_valid, _ = board.is_valid_move(row, col, direction)
+                if is_valid:
+                    possible_moves.append((row, col, direction))
+    return possible_moves
 
-    def get_all_possible_states(self):
+def get_all_possible_states(board: Board):
 
-        possible_moves = self.get_all_possible_moves()
-        possible_states = []
+    possible_moves = get_all_possible_moves()
+    possible_states = []
 
-        for move in possible_moves:
-            new_state = copy.deepcopy(self)
+    for move in possible_moves:
+        new_state = copy.deepcopy(board)
 
-            # Apply the move to the new state
-            row, col, direction = move
-            new_state.make_move(row, col, direction)
+        # Apply the move to the new state
+        row, col, direction = move
+        new_state.make_move(row, col, direction)
 
-            # Add the new state to the list
-            possible_states.append(new_state)
+        # Add the new state to the list
+        possible_states.append(new_state)
 
-        return possible_states
+    return possible_states
 
-def setup_game():
-    n = int(input("Enter the side length of the hexagonal board (4-8): "))
-    if n < 4 or n > 8:
-        raise ValueError("Side length must be between 4 and 8.")
-
-    first_player = input("Who will play first? (X/O): ").strip().upper()
-    if first_player not in ['X', 'O']:
-        raise ValueError("Invalid choice. Choose 'X' or 'O'.")
+def test_generate_states():
+    game = setup_game()
+    game.display_board()
 
-    game = TriggleGame(n, first_player)
+    print(f"\nCurrent player: {game.current_player}")
+    print("Generating all possible moves...")
+    possible_moves = game.get_all_possible_moves()
+    print(f"Total possible moves: {len(possible_moves)}")
+    print(possible_moves)
 
-    game.peg_number = sum(len(row) for row in game.board.state)
-    game.max_sticks = game.calculate_max_sticks()
-
-    return game
+    print("\nGenerating all possible game states...")
+    possible_states = game.get_all_possible_states()
+    print(f"Total possible game states: {len(possible_states)}")
+    # for i, state in enumerate(possible_states[:5]):
+    #     print(f"\nState {i + 1}:")
+    #     state.display_board()
 
 def main():
     game = setup_game()
@@ -372,4 +390,4 @@
     print("\nGame Over!")
 
 if __name__ == "__main__":
-    main()
+    test_generate_states()
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"7e05a13f-0856-4bb6-a415-62c8d098c711\" name=\"Changes\" comment=\"Fix: all pegs occupied bug\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GitHubPullRequestSearchHistory\">{\r\n  &quot;lastFilter&quot;: {\r\n    &quot;state&quot;: &quot;OPEN&quot;,\r\n    &quot;assignee&quot;: &quot;teodorat63&quot;\r\n  }\r\n}</component>\r\n  <component name=\"GithubPullRequestsUISettings\">{\r\n  &quot;selectedUrlAndAccountId&quot;: {\r\n    &quot;url&quot;: &quot;https://github.com/teodorat63/Triggle.git&quot;,\r\n    &quot;accountId&quot;: &quot;09736f50-2334-41ff-83f2-8812f1a4120f&quot;\r\n  }\r\n}</component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 2\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2pUpnQnmsa7BOVdY9dbqGKB0Kv5\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"Python.main.executor\": \"Run\",\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"git-widget-placeholder\": \"master\",\r\n    \"settings.editor.selected.configurable\": \"preferences.editor\"\r\n  }\r\n}]]></component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"main\" type=\"PythonConfigurationType\" factoryName=\"Python\" nameIsGenerated=\"true\">\r\n      <module name=\"Triggle\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/main.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-python-sdk-d7ad00fb9fc3-c546a90a8094-com.jetbrains.pycharm.community.sharedIndexes.bundled-PC-242.23726.102\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"7e05a13f-0856-4bb6-a415-62c8d098c711\" name=\"Changes\" comment=\"\" />\r\n      <created>1732830674860</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1732830674860</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"Initial commit\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733488536531</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733488536531</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"Initial commit\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733488937643</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733488937643</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"Simplified the logic for locating the pegs with its coordinates\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733491684684</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733491684684</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"Simplified the logic for locating the pegs with its coordinates\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733492783110</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733492783110</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"Fixed out-of-bounds validation in is_valid_move method\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733493411876</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733493411876</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00006\" summary=\"added logic to calculate maximum triangles&#10;&#10;- Added `calculate_max_triangles` function for reusability.&#10;- Integrated the function into `is_game_over` to simplify logic.\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733496638079</created>\r\n      <option name=\"number\" value=\"00006\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733496638079</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00007\" summary=\"Finished logic for is_game_over method\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733523693319</created>\r\n      <option name=\"number\" value=\"00007\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733523693319</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00008\" summary=\"Fixed out of bounds bug\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733598322904</created>\r\n      <option name=\"number\" value=\"00008\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733598322905</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00009\" summary=\"Fixed out of bounds bug\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733598344135</created>\r\n      <option name=\"number\" value=\"00009\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733598344135</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00010\" summary=\"Triangle owners displayed properly at the upper half of the triangle\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733603008456</created>\r\n      <option name=\"number\" value=\"00010\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733603008456</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00011\" summary=\"feat: add get_triangle_owner function to determine triangle ownership&#10;supports both downward-facing and upward-facing triangle calculations\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733603862216</created>\r\n      <option name=\"number\" value=\"00011\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733603862216</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00012\" summary=\"feat: implemented capture_all_existing_triangles&#10;Game is now playable!\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733605018591</created>\r\n      <option name=\"number\" value=\"00012\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733605018591</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00013\" summary=\"feat: implemented capture_all_existing_triangles&#10;Game is now playable!\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733605071070</created>\r\n      <option name=\"number\" value=\"00013\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733605071070</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00014\" summary=\"Fix: Out-of-bound issue at is_valid_move\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733605421229</created>\r\n      <option name=\"number\" value=\"00014\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00014\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733605421229</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00015\" summary=\"minor fixes\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733608527154</created>\r\n      <option name=\"number\" value=\"00015\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00015\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733608527154</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00016\" summary=\"feat: Display score on every turn&#10;fix:max_sticks and peg_number calculated only once\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733839308674</created>\r\n      <option name=\"number\" value=\"00016\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00016\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733839308674</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00017\" summary=\"Add validation to prevent duplicate moves by any player in is_valid_move\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733839774772</created>\r\n      <option name=\"number\" value=\"00017\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00017\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733839774772</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00018\" summary=\"feat Add functions to generate possible moves and game states&#10;&#10;- Implemented logic to form all possible moves based on the current player and board state.&#10;- Added functionality to compute all resulting game states from these moves.&#10;- This enhancement supports AI-driven decision-making and analysis of game outcomes.\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733925082563</created>\r\n      <option name=\"number\" value=\"00018\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00018\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733925082563</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00019\" summary=\".\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733925876108</created>\r\n      <option name=\"number\" value=\"00019\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00019\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733925876108</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00020\" summary=\".\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1733926168425</created>\r\n      <option name=\"number\" value=\"00020\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00020\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1733926168425</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00021\" summary=\"Rewmoved get_input it is part of make_move now\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1734027541563</created>\r\n      <option name=\"number\" value=\"00021\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00021\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1734027541563</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00022\" summary=\"Add validation to check if all steps in a move already have sticks\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1734376896484</created>\r\n      <option name=\"number\" value=\"00022\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00022\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1734376896484</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00023\" summary=\"Remove unused player_moves tracking from game logic\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1734376955434</created>\r\n      <option name=\"number\" value=\"00023\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00023\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1734376955434</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00024\" summary=\"fix: End game disiplay\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1734377057051</created>\r\n      <option name=\"number\" value=\"00024\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00024\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1734377057051</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00025\" summary=\"Fix: all pegs occupied bug\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1734715770021</created>\r\n      <option name=\"number\" value=\"00025\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00025\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1734715770021</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00026\" summary=\"Fix: all pegs occupied bug\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1734715818814</created>\r\n      <option name=\"number\" value=\"00026\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00026\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1734715818814</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"27\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"Initial commit\" />\r\n    <MESSAGE value=\"Simplified the logic for locating the pegs with its coordinates\" />\r\n    <MESSAGE value=\"Fixed out-of-bounds validation in is_valid_move method\" />\r\n    <MESSAGE value=\"added logic to calculate maximum triangles&#10;&#10;- Added `calculate_max_triangles` function for reusability.&#10;- Integrated the function into `is_game_over` to simplify logic.\" />\r\n    <MESSAGE value=\"Finished logic for is_game_over method\" />\r\n    <MESSAGE value=\"Fixed out of bounds bug\" />\r\n    <MESSAGE value=\"Triangle owners displayed properly at the upper half of the triangle\" />\r\n    <MESSAGE value=\"feat: add get_triangle_owner function to determine triangle ownership&#10;supports both downward-facing and upward-facing triangle calculations\" />\r\n    <MESSAGE value=\"feat: implemented capture_all_existing_triangles&#10;Game is now playable!\" />\r\n    <MESSAGE value=\"Fix: Out-of-bound issue at is_valid_move\" />\r\n    <MESSAGE value=\"minor fixes\" />\r\n    <MESSAGE value=\"feat: Display score on every turn&#10;fix:max_sticks and peg_number calculated only once\" />\r\n    <MESSAGE value=\"Add validation to prevent duplicate moves by any player in is_valid_move\" />\r\n    <MESSAGE value=\"feat Add functions to generate possible moves and game states&#10;&#10;- Implemented logic to form all possible moves based on the current player and board state.&#10;- Added functionality to compute all resulting game states from these moves.&#10;- This enhancement supports AI-driven decision-making and analysis of game outcomes.\" />\r\n    <MESSAGE value=\".\" />\r\n    <MESSAGE value=\"Rewmoved get_input it is part of make_move now\" />\r\n    <MESSAGE value=\"Add validation to check if all steps in a move already have sticks\" />\r\n    <MESSAGE value=\"Remove unused player_moves tracking from game logic\" />\r\n    <MESSAGE value=\"fix: End game disiplay\" />\r\n    <MESSAGE value=\"Fix: all pegs occupied bug\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"Fix: all pegs occupied bug\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision fe3ef5e37143e9b96350c68fb9144c256179c829)
+++ b/.idea/workspace.xml	(date 1735057555739)
@@ -4,8 +4,9 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="7e05a13f-0856-4bb6-a415-62c8d098c711" name="Changes" comment="Fix: all pegs occupied bug">
+    <list default="true" id="7e05a13f-0856-4bb6-a415-62c8d098c711" name="Changes" comment="Refactor game logic: Separated concerns for board initialization, display and game logic">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/main.py" beforeDir="false" afterPath="$PROJECT_DIR$/main.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -43,14 +44,14 @@
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent"><![CDATA[{
-  "keyToString": {
-    "Python.main.executor": "Run",
-    "RunOnceActivity.ShowReadmeOnStart": "true",
-    "git-widget-placeholder": "master",
-    "settings.editor.selected.configurable": "preferences.editor"
+  <component name="PropertiesComponent">{
+  &quot;keyToString&quot;: {
+    &quot;Python.main.executor&quot;: &quot;Run&quot;,
+    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
+    &quot;git-widget-placeholder&quot;: &quot;master&quot;,
+    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.editor&quot;
   }
-}]]></component>
+}</component>
   <component name="RunManager">
     <configuration name="main" type="PythonConfigurationType" factoryName="Python" nameIsGenerated="true">
       <module name="Triggle" />
@@ -299,7 +300,15 @@
       <option name="project" value="LOCAL" />
       <updated>1734715818814</updated>
     </task>
-    <option name="localTasksCounter" value="27" />
+    <task id="LOCAL-00027" summary="Refactor game logic: Separated concerns for board initialization, display and game logic">
+      <option name="closed" value="true" />
+      <created>1734717085796</created>
+      <option name="number" value="00027" />
+      <option name="presentableId" value="LOCAL-00027" />
+      <option name="project" value="LOCAL" />
+      <updated>1734717085796</updated>
+    </task>
+    <option name="localTasksCounter" value="28" />
     <servers />
   </component>
   <component name="VcsManagerConfiguration">
@@ -323,6 +332,7 @@
     <MESSAGE value="Remove unused player_moves tracking from game logic" />
     <MESSAGE value="fix: End game disiplay" />
     <MESSAGE value="Fix: all pegs occupied bug" />
-    <option name="LAST_COMMIT_MESSAGE" value="Fix: all pegs occupied bug" />
+    <MESSAGE value="Refactor game logic: Separated concerns for board initialization, display and game logic" />
+    <option name="LAST_COMMIT_MESSAGE" value="Refactor game logic: Separated concerns for board initialization, display and game logic" />
   </component>
 </project>
\ No newline at end of file
Index: game.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import copy\r\n\r\nclass Board:\r\n    def __init__(self, side_length):\r\n        self.side_length = side_length\r\n        self.state = self.initialize_board()\r\n        self.sticks = set()\r\n        self.triangles = {}\r\n\r\n    def initialize_board(self):\r\n        return (\r\n                [[None] * (self.side_length + i) for i in range(self.side_length)] +  # Upper triangle\r\n                [[None] * (2 * self.side_length - i - 1) for i in range(1, self.side_length)]  # Lower triangle\r\n        )\r\n\r\n\r\nclass GameRendered:\r\n\r\n    def display_board(self, board: Board):\r\n        n = board.side_length\r\n        max_width = 2 * board.side_length - 1\r\n        column_numbers = '     '.join(f\"{i}\" for i in range(1, max_width + 1))\r\n\r\n        # Display column numbers\r\n        print(f\"   {'   ' * (n - 1)}{column_numbers}\")\r\n\r\n        for i in range(len(board.state)):\r\n\r\n            offset = abs(n - 1 - i)  # Indent for alignment\r\n            row_label = chr(65 + i)\r\n\r\n            # Peg line\r\n            peg_line = []\r\n            for j in range(len(board.state[i])):\r\n                peg_line.append(\"●\")\r\n                peg_line.append(\"-----\" if self.is_part_of_horizontal_stick(board, i, j) else \"     \")\r\n\r\n            # First triangle line (diagonal sticks)\r\n            first_triangle_line = []\r\n            for j in range(len(board.state[i])):\r\n                down_left = self.is_part_of_diagonal_stick(board, i, j, \"DL\")\r\n                down_right = self.is_part_of_diagonal_stick(board, i, j, \"DD\")\r\n\r\n                # Add left diagonal\r\n                first_triangle_line.append(\"/\" if down_left else \" \")\r\n\r\n                # Add space between left and right diagonals\r\n                first_triangle_line.append(\" \" * 1)\r\n\r\n                # Add right diagonal\r\n                first_triangle_line.append(\"\\\\\" if down_right else \" \")\r\n                #first_triangle_line.append(\"   \")\r\n\r\n                # Get the triangle owner upper\r\n                triangle_owner = self.get_triangle_owner(board, i, j, True)\r\n                first_triangle_line.append(f\" {triangle_owner} \")\r\n\r\n            # Second triangle line\r\n            second_triangle_line = []\r\n            for j in range(len(board.state[i])):\r\n                down_left = self.is_part_of_diagonal_stick(board, i, j, \"DL\")\r\n                second_triangle_line.append(\"/\" if down_left else \" \")\r\n\r\n                # Add the triangle owner\r\n                triangle_owner = self.get_triangle_owner(board, i, j, False)\r\n                second_triangle_line.append(f\"{triangle_owner}\")\r\n\r\n                down_right = self.is_part_of_diagonal_stick(board,i, j, \"DD\")\r\n                second_triangle_line.append(\"\\\\\" if down_right else \" \")\r\n\r\n            # Print peg line\r\n            print(f\"{row_label} {'   ' * offset}{''.join(peg_line)}\")\r\n\r\n            if i < len(board.state) - 1:  # Avoid printing after the last peg line\r\n                print(f\" {'   ' * offset}{''.join(first_triangle_line)}\")\r\n                print(f\"{'   ' * offset}{' '.join(second_triangle_line)}\")\r\n\r\n        print(f\"   {'   ' * (n - 1)}{column_numbers}\")\r\n\r\n    @staticmethod\r\n    def is_part_of_horizontal_stick(board: Board, row, col):\r\n        if ((row, col), (row, col + 1)) in board.sticks:\r\n            return True\r\n        return False\r\n\r\n    @staticmethod\r\n    def is_part_of_diagonal_stick(board: Board, row, col, direction):\r\n        if direction == \"DL\" and row < board.side_length - 1:  #\r\n            return ((row, col), (row + 1, col)) in board.sticks or ((row + 1, col), (row, col)) in board.sticks\r\n        if direction == \"DL\" and row >= board.side_length - 1:\r\n            return ((row, col), (row + 1, col-1)) in board.sticks or ((row + 1, col-1), (row, col)) in board.sticks\r\n        if direction == \"DD\" and row < board.side_length - 1:\r\n            return ((row, col), (row + 1, col + 1)) in board.sticks or ((row + 1, col + 1), (row, col)) in board.sticks\r\n        if direction == \"DD\" and row >= board.side_length - 1:\r\n            return ((row, col), (row + 1, col)) in board.sticks or ((row + 1, col), (row, col)) in board.sticks\r\n        return False\r\n\r\n    @staticmethod\r\n    def get_triangle_owner(board: Board, row, col, downward):\r\n        triangle_owner = \" \"\r\n\r\n        # Determine potential triangles based on `firstRow` flag\r\n        if downward:  # Use downward-facing triangle formula\r\n            if row < board.side_length - 1:  # Upper triangle board\r\n                potential_triangles = [\r\n                    [(row, col), (row, col + 1), (row + 1, col+1)]  # Downward-facing triangle\r\n                ]\r\n            else:  # Lower triangle board\r\n                potential_triangles = [\r\n                    [(row, col), (row, col + 1), (row + 1, col)]  # Downward-facing triangle\r\n                ]\r\n        else:  # Use upward-facing triangle formula\r\n            if row < board.side_length - 1:  # Upper triangle board\r\n                potential_triangles = [\r\n                    [(row, col), (row + 1, col), (row + 1, col + 1)]  # Upward-facing triangle\r\n                ]\r\n            else:  # Lower triangle board\r\n                potential_triangles = [\r\n                    [(row, col), (row + 1, col - 1), (row + 1, col)]  # Upward-facing triangle\r\n                ]\r\n\r\n        # Check ownership for potential triangles\r\n        for corners in potential_triangles:\r\n            triangle_key = tuple(sorted(corners))\r\n            if triangle_key in board.triangles:\r\n                triangle_owner = board.triangles[triangle_key]\r\n                break  # Return the first matching triangle's owner\r\n\r\n        return triangle_owner\r\n\r\n\r\nclass TriggleGame:\r\n    def __init__(self, side_length,first_player):\r\n        self.board = Board(side_length)\r\n        self.game_rendered = GameRendered()\r\n        self.current_player = first_player\r\n        self.max_sticks = self.calculate_max_sticks()\r\n        self.max_triangles = self.calculate_max_triangles()\r\n        self.peg_number = sum(len(row) for row in self.board.state)\r\n\r\n    def display_board(self):\r\n        self.game_rendered.display_board(self.board)\r\n\r\n    def is_valid_move(self, row, col, direction):\r\n\r\n        occupied = True\r\n\r\n        r, c = row, col\r\n\r\n        for step in range(3):\r\n            # Set deltas based on the current row\r\n            if r < self.board.side_length - 1:  # Upper triangle\r\n                deltas = {\r\n                    'D': (0, 1),\r\n                    'DL': (1, 0),\r\n                    'DD': (1, 1)\r\n                }\r\n            else:  # Lower triangle\r\n                deltas = {\r\n                    'D': (0, 1),\r\n                    'DL': (1, -1),\r\n                    'DD': (1, 0)\r\n                }\r\n\r\n            if direction not in deltas:\r\n                return False, \"Invalid direction. Use 'D', 'DL', or 'DD'.\"\r\n\r\n            dr, dc = deltas[direction]\r\n            next_r, next_c = r + dr, c + dc\r\n\r\n            # Check if the new position is within bounds\r\n            if not (0 <= next_r < len(self.board.state) and 0 <= next_c < len(self.board.state[next_r])):\r\n                return False, f\"Peg at step {step + 1} is out of bounds.\"\r\n\r\n            # Check if there's a stick already in this step\r\n            if not (((r, c), (next_r, next_c)) in self.board.sticks):\r\n                occupied = False\r\n\r\n            r, c = next_r, next_c\r\n\r\n        if occupied:\r\n            return False, \"This move is invalid: All steps in the path are occupied.\"\r\n\r\n        return True, None\r\n\r\n    def make_move(self, row, col, direction):\r\n\r\n        is_valid, error_message = self.is_valid_move(row, col, direction)\r\n        if not is_valid:\r\n            raise ValueError(error_message)\r\n\r\n        r, c = row, col\r\n\r\n        for _ in range(3):\r\n\r\n            # Update deltas based on the current value of r\r\n\r\n            #TOP TRIANGLE\r\n            if r < self.board.side_length - 1:\r\n                deltas = {\r\n                    'D': (0, 1),\r\n                    'DL': (1, 0),\r\n                    'DD': (1, 1)\r\n                }\r\n            else:\r\n                #BOTTOM TRIANGLE\r\n                deltas = {\r\n                    'D': (0, 1),\r\n                    'DL': (1, -1),\r\n                    'DD': (1, 0)\r\n                }\r\n\r\n            dr, dc = deltas[direction]\r\n\r\n            if not (0 <= r < len(self.board.side_length) and 0 <= c < len(self.board.side_length[r])):\r\n                raise ValueError(\"Move out of bounds.\")\r\n\r\n            next_r, next_c = r + dr, c + dc\r\n            self.board.sticks.add(((r, c), (next_r, next_c)))\r\n\r\n            r, c = next_r, next_c\r\n\r\n        self.check_and_capture_triangles()\r\n        self.switch_player()\r\n\r\n    def check_and_capture_triangles(self):\r\n        def is_triangle_completed(corners):\r\n            return all(\r\n                ((corners[i], corners[(i + 1) % len(corners)]) in self.board.sticks or\r\n                 (corners[(i + 1) % len(corners)], corners[i]) in self.board.sticks)\r\n                for i in range(len(corners))\r\n            )\r\n\r\n        # Traverse the board\r\n        for row in range(len(self.board.state)):\r\n            for col in range(len(self.board.state[row])):\r\n                potential_triangles = []\r\n\r\n                # Add potential triangles based on the peg's location\r\n                if row < self.board.side_length - 1:  # Upper triangle\r\n                    potential_triangles.extend([\r\n                        # Triangle facing down\r\n                        [(row, col), (row, col + 1), (row + 1, col+1)],\r\n                        # Triangle facing up\r\n                        [(row, col), (row + 1, col), (row + 1, col + 1)]\r\n                    ])\r\n                else:  # Lower triangle\r\n                    potential_triangles.extend([\r\n                        # Triangle facing down\r\n                        [(row, col), (row, col + 1), (row + 1, col)],\r\n                        # Triangle facing up\r\n                        [(row, col), (row + 1, col - 1), (row + 1, col)]\r\n                    ])\r\n\r\n                # Check each potential triangle\r\n                for corners in potential_triangles:\r\n                    if is_triangle_completed(corners):\r\n                        # Sort the corners to have a consistent representation\r\n                        triangle_key = tuple(sorted(corners))\r\n                        if triangle_key not in self.board.triangles:\r\n                            self.board.triangles[triangle_key] = self.current_player\r\n\r\n    def switch_player(self):\r\n        self.current_player = 'X' if self.current_player == 'O' else 'O'\r\n\r\n    def is_game_over(self):\r\n\r\n        x_count = sum(1 for owner in self.board.triangles.values() if owner == 'X')\r\n        o_count = sum(1 for owner in self.board.triangles.values() if owner == 'O')\r\n        print(\"Scoreboard\")\r\n        print(f\"X: {'█' * x_count} ({x_count})\")\r\n        print(f\"O: {'█' * o_count} ({o_count})\")\r\n\r\n        if x_count + o_count == self.max_triangles:\r\n            print(\"Game over: All triangles are captured.\")\r\n            return True\r\n\r\n        if x_count > self.max_triangles // 2:\r\n            print(\"Game over: Player X has won by majority!\")\r\n            return True\r\n\r\n        if o_count > self.max_triangles // 2:\r\n            print(\"Game over: Player O has won by majority!\")\r\n            return True\r\n\r\n        if len(self.board.sticks) == self.max_sticks:\r\n            print(\"Game over: All sticks are placed.\")\r\n            return True\r\n\r\n        return False\r\n\r\n    def calculate_max_triangles(self):\r\n        max_triangles = 0\r\n        for step in range(self.board.side_length - 1):\r\n            max_triangles += 2 * len(self.board.state[step]) - 1\r\n        max_triangles = max_triangles * 2\r\n        return max_triangles\r\n\r\n    def calculate_max_sticks(self):\r\n        corner_connections = 6 * 3\r\n        side_connections = (self.board.side_length - 2) * 4 * 6\r\n        center_connections = (self.peg_number - 6 - (self.board.side_length - 2) * 6) * 6\r\n        total_connections = corner_connections + side_connections + center_connections\r\n        number_of_sticks = total_connections / 2\r\n        return number_of_sticks\r\n\r\n    def get_all_possible_moves(self):\r\n\r\n        possible_moves = []\r\n\r\n        for row in range(len(self.board.state)):\r\n            for col in range(len(self.board.state[row])):\r\n                for direction in ['D', 'DL', 'DD']:\r\n                    is_valid, _ = self.is_valid_move(row, col, direction)\r\n                    if is_valid:\r\n                        possible_moves.append((row, col, direction))\r\n        return possible_moves\r\n\r\n    def get_all_possible_states(self):\r\n\r\n        possible_moves = self.get_all_possible_moves()\r\n        possible_states = []\r\n\r\n        for move in possible_moves:\r\n            new_state = copy.deepcopy(self)\r\n\r\n            # Apply the move to the new state\r\n            row, col, direction = move\r\n            new_state.make_move(row, col, direction)\r\n\r\n            # Add the new state to the list\r\n            possible_states.append(new_state)\r\n\r\n        return possible_states\r\n\r\ndef setup_game():\r\n    n = int(input(\"Enter the side length of the hexagonal board (4-8): \"))\r\n    if n < 4 or n > 8:\r\n        raise ValueError(\"Side length must be between 4 and 8.\")\r\n\r\n    first_player = input(\"Who will play first? (X/O): \").strip().upper()\r\n    if first_player not in ['X', 'O']:\r\n        raise ValueError(\"Invalid choice. Choose 'X' or 'O'.\")\r\n\r\n    game = TriggleGame(n, first_player)\r\n\r\n    return game\r\n\r\ndef main():\r\n    game = setup_game()\r\n\r\n    while not game.is_game_over():\r\n        print(f\"\\n{game.current_player}'s turn.\")\r\n        game.display_board()\r\n\r\n        try:\r\n            move = input(\"Enter your move (format: row column direction): \").strip()\r\n            row, col, direction = move.rsplit(' ', 2)\r\n            row, col = ord(row.upper()) - 65, int(col) - 1\r\n            direction = direction.upper()\r\n            game.make_move(row, col, direction)\r\n\r\n        except ValueError as e:\r\n            print(f\"Error: {e}\")\r\n        except Exception as e:\r\n            print(f\"Unexpected error: {e}\")\r\n\r\n    game.display_board()\r\n    print(\"\\nGame Over!\")\r\n
===================================================================
diff --git a/game.py b/game.py
--- a/game.py	(revision fe3ef5e37143e9b96350c68fb9144c256179c829)
+++ b/game.py	(date 1735057637302)
@@ -13,6 +13,48 @@
                 [[None] * (2 * self.side_length - i - 1) for i in range(1, self.side_length)]  # Lower triangle
         )
 
+    def is_valid_move(self, row, col, direction):
+
+        occupied = True
+
+        r, c = row, col
+
+        for step in range(3):
+            # Set deltas based on the current row
+            if r < self.side_length - 1:  # Upper triangle
+                deltas = {
+                    'D': (0, 1),
+                    'DL': (1, 0),
+                    'DD': (1, 1)
+                }
+            else:  # Lower triangle
+                deltas = {
+                    'D': (0, 1),
+                    'DL': (1, -1),
+                    'DD': (1, 0)
+                }
+
+            if direction not in deltas:
+                return False, "Invalid direction. Use 'D', 'DL', or 'DD'."
+
+            dr, dc = deltas[direction]
+            next_r, next_c = r + dr, c + dc
+
+            # Check if the new position is within bounds
+            if not (0 <= next_r < len(self.state) and 0 <= next_c < len(self.state[next_r])):
+                return False, f"Peg at step {step + 1} is out of bounds."
+
+            # Check if there's a stick already in this step
+            if not (((r, c), (next_r, next_c)) in self.sticks):
+                occupied = False
+
+            r, c = next_r, next_c
+
+        if occupied:
+            return False, "This move is invalid: All steps in the path are occupied."
+
+        return True, None
+
 
 class GameRendered:
 
@@ -134,58 +176,17 @@
         self.board = Board(side_length)
         self.game_rendered = GameRendered()
         self.current_player = first_player
-        self.max_sticks = self.calculate_max_sticks()
+        self.max_sticks = None
         self.max_triangles = self.calculate_max_triangles()
-        self.peg_number = sum(len(row) for row in self.board.state)
+        self.peg_number = None
 
     def display_board(self):
         self.game_rendered.display_board(self.board)
 
-    def is_valid_move(self, row, col, direction):
-
-        occupied = True
-
-        r, c = row, col
-
-        for step in range(3):
-            # Set deltas based on the current row
-            if r < self.board.side_length - 1:  # Upper triangle
-                deltas = {
-                    'D': (0, 1),
-                    'DL': (1, 0),
-                    'DD': (1, 1)
-                }
-            else:  # Lower triangle
-                deltas = {
-                    'D': (0, 1),
-                    'DL': (1, -1),
-                    'DD': (1, 0)
-                }
-
-            if direction not in deltas:
-                return False, "Invalid direction. Use 'D', 'DL', or 'DD'."
-
-            dr, dc = deltas[direction]
-            next_r, next_c = r + dr, c + dc
-
-            # Check if the new position is within bounds
-            if not (0 <= next_r < len(self.board.state) and 0 <= next_c < len(self.board.state[next_r])):
-                return False, f"Peg at step {step + 1} is out of bounds."
-
-            # Check if there's a stick already in this step
-            if not (((r, c), (next_r, next_c)) in self.board.sticks):
-                occupied = False
-
-            r, c = next_r, next_c
-
-        if occupied:
-            return False, "This move is invalid: All steps in the path are occupied."
-
-        return True, None
 
     def make_move(self, row, col, direction):
 
-        is_valid, error_message = self.is_valid_move(row, col, direction)
+        is_valid, error_message = self.board.is_valid_move(row, col, direction)
         if not is_valid:
             raise ValueError(error_message)
 
@@ -212,7 +213,7 @@
 
             dr, dc = deltas[direction]
 
-            if not (0 <= r < len(self.board.side_length) and 0 <= c < len(self.board.side_length[r])):
+            if not (0 <= r < len(self.board.state) and 0 <= c < len(self.board.state[r])):
                 raise ValueError("Move out of bounds.")
 
             next_r, next_c = r + dr, c + dc
@@ -304,47 +305,67 @@
         number_of_sticks = total_connections / 2
         return number_of_sticks
 
-    def get_all_possible_moves(self):
+def setup_game():
+    n = int(input("Enter the side length of the hexagonal board (4-8): "))
+    if n < 4 or n > 8:
+        raise ValueError("Side length must be between 4 and 8.")
+
+    first_player = input("Who will play first? (X/O): ").strip().upper()
+    if first_player not in ['X', 'O']:
+        raise ValueError("Invalid choice. Choose 'X' or 'O'.")
+
+    game = TriggleGame(n, first_player)
+
+    game.peg_number = sum(len(row) for row in game.board.state)
+    game.max_sticks = game.calculate_max_sticks()
+
+    return game
+
+def get_all_possible_moves(board: Board):
 
-        possible_moves = []
+    possible_moves = []
 
-        for row in range(len(self.board.state)):
-            for col in range(len(self.board.state[row])):
-                for direction in ['D', 'DL', 'DD']:
-                    is_valid, _ = self.is_valid_move(row, col, direction)
-                    if is_valid:
-                        possible_moves.append((row, col, direction))
-        return possible_moves
+    for row in range(len(board.state)):
+        for col in range(len(board.state[row])):
+            for direction in ['D', 'DL', 'DD']:
+                is_valid, _ = board.is_valid_move(row, col, direction)
+                if is_valid:
+                    possible_moves.append((row, col, direction))
+    return possible_moves
 
-    def get_all_possible_states(self):
+def get_all_possible_states(board: Board):
 
-        possible_moves = self.get_all_possible_moves()
-        possible_states = []
+    possible_moves = get_all_possible_moves()
+    possible_states = []
 
-        for move in possible_moves:
-            new_state = copy.deepcopy(self)
+    for move in possible_moves:
+        new_state = copy.deepcopy(board)
 
-            # Apply the move to the new state
-            row, col, direction = move
-            new_state.make_move(row, col, direction)
+        # Apply the move to the new state
+        row, col, direction = move
+        new_state.make_move(row, col, direction)
 
-            # Add the new state to the list
-            possible_states.append(new_state)
+        # Add the new state to the list
+        possible_states.append(new_state)
 
-        return possible_states
+    return possible_states
 
-def setup_game():
-    n = int(input("Enter the side length of the hexagonal board (4-8): "))
-    if n < 4 or n > 8:
-        raise ValueError("Side length must be between 4 and 8.")
+def test_generate_states():
+    game = setup_game()
+    game.display_board()
 
-    first_player = input("Who will play first? (X/O): ").strip().upper()
-    if first_player not in ['X', 'O']:
-        raise ValueError("Invalid choice. Choose 'X' or 'O'.")
+    print(f"\nCurrent player: {game.current_player}")
+    print("Generating all possible moves...")
+    possible_moves = game.get_all_possible_moves()
+    print(f"Total possible moves: {len(possible_moves)}")
+    print(possible_moves)
 
-    game = TriggleGame(n, first_player)
-
-    return game
+    print("\nGenerating all possible game states...")
+    possible_states = game.get_all_possible_states()
+    print(f"Total possible game states: {len(possible_states)}")
+    # for i, state in enumerate(possible_states[:5]):
+    #     print(f"\nState {i + 1}:")
+    #     state.display_board()
 
 def main():
     game = setup_game()
@@ -367,3 +388,6 @@
 
     game.display_board()
     print("\nGame Over!")
+
+if __name__ == "__main__":
+    test_generate_states()
